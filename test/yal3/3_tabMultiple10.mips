.data
chaine0: .asciiz "\n"
.text
main:
# init variable repérer la zone des variables
move $s7, $sp
# Init des variables à 0
add $v0, $zero, $zero
lw $v0, -4($s7)
add $sp, $sp, -4
j finFonc1
#Fonction test
fonc1:
#Creation de la base de la pile 
#Empile l'adresse de retour 
sw $ra,($sp) 
addi $sp,$sp,-4 
#Sauver la base locale de la pile 
sw $s7,($sp) 
addi $sp,$sp,-4 
#Empiler le n° bloc 
li $v0,1
sw $v0,($sp) 
addi $sp, $sp, -4 
move $s7,$sp 
#Bloc d'instruction de la fonction test 
# calcul de la valeur a affecter à cmpt
# opération  + , calcul de gauche
# charge la variable cmpt
move $t8, $s7 
itr1: 
lw $v0, 4($t8) 
addi $v1, $zero, 0 
sub $v0, $v0, $v1
beqz $v0, finitr1
lw $t8, 8($t8) 
j itr1 
finitr1: 
lw $v0, 0($t8)
# empiler gauche
sw $v0, 0($sp)
addi $sp, $sp, -4
# calcul de droite
# constante entière
li $v0, 1
# dépile gauche dans $t8
addi $sp, $sp, 4
lw $t8, 0($sp)
# addition gauche droite
add $v0, $v0, $t8
# emplile 
sw $v0, 0($sp)
addi $sp, $sp, -4
# Remonte le chainage
move $t8, $s7 
itr0: 
lw $v0, 4($t8) 
addi $v1, $zero, 0 
sub $v1, $v0, $v1
beqz $v1, finitr0
lw $t8, 8($t8) 
j itr0 
finitr0: 
#Dépile 
addi $sp, $sp, 4
lw $v0, 0($sp)
sw $v0, 0($t8)
#Retour de la fonction
# opération  * , calcul de gauche
# constante entière
li $v0, 10
# empiler gauche
sw $v0, 0($sp)
addi $sp, $sp, -4
# calcul de droite
# charge la variable cmpt
move $t8, $s7 
itr2: 
lw $v0, 4($t8) 
addi $v1, $zero, 0 
sub $v0, $v0, $v1
beqz $v0, finitr2
lw $t8, 8($t8) 
j itr2 
finitr2: 
lw $v0, 0($t8)
# dépile gauche dans $t8
addi $sp, $sp, 4
lw $t8, 0($sp)
# multiplication gauche droite
mult $v0, $t8
mflo $v0
sw $v0, 16($s7) 
j sortieFonc1 
sortieFonc1:
lw $ra, 12($s7) 
#Remonte la pile 
addi $sp, $s7, 12 
lw $s7, 8($s7) 
jr $ra 
finFonc1:
# Début du Tantque 0: label + évaluation de expr
Tantque0 :
# opération  != , calcul de gauche
# charge la variable cmpt
move $t8, $s7 
itr3: 
lw $v0, 4($t8) 
addi $v1, $zero, 0 
sub $v0, $v0, $v1
beqz $v0, finitr3
lw $t8, 8($t8) 
j itr3 
finitr3: 
lw $v0, 0($t8)
# empiler gauche
sw $v0, 0($sp)
addi $sp, $sp, -4
# calcul de droite
# constante entière
li $v0, 10
# dépile gauche dans $t8
addi $sp, $sp, 4
lw $t8, 0($sp)
# Début comparaison différence
Si0:
# Soustraction des 2 variables comparées
sub $v0, $t8, $v0
# Comparaison à 0 du résultat
beqz $v0, Sinon0
# Si différent de 0 renvoie true
Alors0:
li $v0, 1
b Fin0
# Sinon égal à 0 renvoie false
Sinon0:
li $v0, 0
Fin0:
beqz $v0, FinTantque0
#Tantque 0 bloc instruction
# Print d'une expression
addi $sp, $sp, -4 
jal fonc1 
addi $sp, $sp, 4 
lw $v0, ($sp)
add $a0, $v0, $zero
li $v0, 1
syscall
# Print d'une string
li $v0, 4
la $a0, chaine0
syscall
b Tantque0
FinTantque0:
end:
li $v0, 10         # retour au système
syscall
